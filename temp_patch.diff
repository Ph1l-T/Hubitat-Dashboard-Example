*** Begin Patch
*** Update File: script.js
@@
 function sendHubitatCommand(deviceId, command, value) {
     let url = `${HUBITAT_CLOUD_BASE_URL}${deviceId}/${command}`;
     if (value) url += `/${value}`;
     url += `?access_token=${HUBITAT_ACCESS_TOKEN}`;
 
     console.log(`Enviando comando para o Hubitat: ${url}`);
 
     fetch(url)
         .then(response => response.ok ? response.json() : Promise.reject(response))
         .then(data => console.log('Resposta do Hubitat:', data))
         .catch(error => console.error('Erro ao enviar comando para o Hubitat:', error));
 }
 
+// --- Sincronização de estado inicial com o Hubitat ---
+
+// Cache simples em memória para evitar requisições repetidas na carga
+const deviceStateCache = new Map(); // Map<deviceId, { raw: object, switch: 'on'|'off'|undefined, windowShade: string|undefined }>
+
+function fetchHubitatDeviceInfo(deviceId) {
+    const url = `${HUBITAT_CLOUD_BASE_URL}${deviceId}?access_token=${HUBITAT_ACCESS_TOKEN}`;
+    return fetch(url)
+        .then((res) => (res.ok ? res.json() : Promise.reject(res)))
+        .then((data) => {
+            // Normaliza atributos úteis
+            let switchValue;
+            let windowShadeValue;
+            if (Array.isArray(data.attributes)) {
+                for (const attr of data.attributes) {
+                    if (attr.name === 'switch') switchValue = attr.currentValue;
+                    if (attr.name === 'windowShade') windowShadeValue = attr.currentValue;
+                }
+            }
+            const normalized = { raw: data, switch: switchValue, windowShade: windowShadeValue };
+            deviceStateCache.set(String(deviceId), normalized);
+            return normalized;
+        })
+        .catch((err) => {
+            console.error('Erro ao buscar estado do dispositivo', deviceId, err);
+            return null;
+        });
+}
+
+function getCachedOrFetch(deviceId) {
+    const key = String(deviceId);
+    if (deviceStateCache.has(key)) return Promise.resolve(deviceStateCache.get(key));
+    return fetchHubitatDeviceInfo(key);
+}
+
+function mapStateForDeviceType(deviceInfo, deviceType) {
+    // Retorna 'on' | 'off' | 'closed' conforme o tipo
+    if (!deviceInfo) return null;
+    if (deviceType === 'shader') {
+        const v = (deviceInfo.windowShade || '').toLowerCase();
+        // Considera qualquer estado aberto/abrindo como ligado visualmente
+        if (v === 'open' || v === 'opening' || v === 'partially open' || v === 'partially_open') return 'on';
+        if (v === 'closed' || v === 'closing') return 'closed';
+        return null;
+    }
+    const sw = (deviceInfo.switch || '').toLowerCase();
+    if (sw === 'on') return 'on';
+    if (sw === 'off') return 'off';
+    return null;
+}
+
+function setElementVisualState(el, deviceType, state) {
+    if (!state) return;
+    const img = el.querySelector('.control-icon') || el.querySelector('img');
+    const stateEl = el.querySelector('.control-state');
+
+    const icons = {
+        light: {
+            on: 'images/icons/icon-small-light-on.svg',
+            off: 'images/icons/icon-small-light-off.svg',
+        },
+        tv: {
+            on: 'images/icons/icon-small-tv-on.svg',
+            off: 'images/icons/icon-small-tv-off.svg',
+        },
+        shader: {
+            on: 'images/icons/icon-small-shader-on.svg',
+            off: 'images/icons/icon-small-shader-off.svg',
+        },
+    };
+
+    const kind = icons[deviceType] ? deviceType : 'light';
+
+    if (deviceType === 'shader') {
+        const normalized = state === 'on' ? 'on' : 'closed';
+        if (img) img.src = normalized === 'on' ? icons.shader.on : icons.shader.off;
+        el.dataset.state = normalized;
+        if (stateEl) stateEl.textContent = normalized === 'on' ? 'Abertas' : 'Fechadas';
+        return;
+    }
+
+    const normalized = state === 'on' ? 'on' : 'off';
+    if (img) img.src = normalized === 'on' ? icons[kind].on : icons[kind].off;
+    el.dataset.state = normalized;
+    if (stateEl) stateEl.textContent = normalized === 'on' ? 'ON' : 'OFF';
+}
+
+function collectAllDeviceIdsFromDOM() {
+    const ids = new Set();
+    // Elementos com um único deviceId
+    document.querySelectorAll('[data-device-id]').forEach((el) => {
+        const id = el.getAttribute('data-device-id');
+        if (id) ids.add(String(id).trim());
+    });
+    // Elementos com múltiplos deviceIds (grupo)
+    document.querySelectorAll('[data-device-ids]').forEach((el) => {
+        const raw = el.getAttribute('data-device-ids');
+        if (!raw) return;
+        raw.split(',').map((s) => s.trim()).filter(Boolean).forEach((id) => ids.add(String(id)));
+    });
+    return ids;
+}
+
+function syncElementFromCache(el) {
+    // device-type pode ser definido no HTML. Padrão: 'light'
+    const deviceType = (el.getAttribute('data-device-type') || 'light').toLowerCase();
+
+    // Caso grupo de dispositivos (ex.: luzes agrupadas na home)
+    const group = el.getAttribute('data-device-ids');
+    if (group) {
+        const ids = group.split(',').map((s) => s.trim()).filter(Boolean);
+        // Regra: mostra ON se QUALQUER um estiver ON (mais intuitivo para "desligar todos" no próximo toque)
+        let anyOn = false;
+        for (const id of ids) {
+            const info = deviceStateCache.get(String(id));
+            const mapped = mapStateForDeviceType(info, deviceType);
+            if (mapped === 'on') { anyOn = true; break; }
+        }
+        setElementVisualState(el, deviceType, anyOn ? 'on' : (deviceType === 'shader' ? 'closed' : 'off'));
+        return;
+    }
+
+    // Caso dispositivo único
+    const id = el.getAttribute('data-device-id');
+    if (id) {
+        const info = deviceStateCache.get(String(id));
+        const mapped = mapStateForDeviceType(info, deviceType);
+        if (mapped) setElementVisualState(el, deviceType, mapped);
+    }
+}
+
+function syncAllElementsFromCache() {
+    document.querySelectorAll('[data-device-id], [data-device-ids]').forEach((el) => syncElementFromCache(el));
+}
+
+function refreshAllDeviceStates() {
+    const ids = Array.from(collectAllDeviceIdsFromDOM());
+    if (ids.length === 0) return Promise.resolve();
+    return Promise.all(ids.map((id) => getCachedOrFetch(id))).then(() => {
+        syncAllElementsFromCache();
+    });
+}
+
+document.addEventListener('DOMContentLoaded', () => {
+    // Sincroniza estados reais ao abrir a interface
+    refreshAllDeviceStates().catch((e) => console.error('Falha ao sincronizar estados iniciais', e));
+});
+
*** End Patch